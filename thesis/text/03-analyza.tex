% ==================================================== %
% Chapter: Analýza vybraných kryptografických knihoven %
% Status: Final                                        %
% ==================================================== %
\label{analyza}

Teoretická východiska popsaná v~předchozích kapitolách nám poskytují dobrou představu o~tom, které aspekty open-source softwaru a~konkrétně kryptografických knihoven mohou být re\-le\-vant\-ní pro jejich důvěryhodnost a~bezpečnou použitelnost; tyto poznatky nyní vztáhneme ke kon\-krét\-ním vybraným knihovnám. Dále v~této kapitole navrhneme a~porovnáme několik způsobů identifikace čas\-tých chyb v~jejich použití a~tyto způsoby opět demonstrujeme na vybraných knihovnách. Tím získáme potřebné informace pro formulaci výsledné metody hodnocení knihoven.

\section{Model hrozeb}

Aby mělo dobrý smysl mluvit o~bezpečnosti kryptografických knihoven, je nejdřív potřeba vymezit, co takový pojem vůbec obnáší, tedy určit model hrozeb, které mohou bezpečnost knihoven kompromitovat. Ve specifickém případě kryptografických open-source knihoven přicházejí v~úvahu následující hrozby:

\subsection{Zadní vrátka v knihovně}

Termín \emph{zadní vrátka} (angl.\ \emph{backdoor}) v~softwaru obecně označuje jakoukoli funkcionalitu, kterou autor softwaru záměrně vloží do jeho kódu za účelem pozdějšího obcházení jeho bezpečnostních mechanismů.

Klíčovou vlastností zadních vrátek je jejich nedetekovatelnost pro uživatele, resp.\ pro kohokoli s~výjimkou jejich autora. Není proto v~našich silách v~této práci popsat obecný způsob, jak by se kryptografická zadní vrátka dala odhalit, snad kromě velmi průhledných případů. Ve zbytku textu se proto budeme zabývat převážně hrozbami, které přicházejí skrze jiné aktéry, než jsou správci knihovny. Existence zadních vrátek v~knihovně je přesto skutečnou hrozbou, kterou je třeba pro úplnost alespoň zmínit, přičemž se jeví jako vhodné tuto hrozbu rozlišit na dvě kategorie.

\subsubsection{Zadní vrátka na úrovni kryptografických algoritmů}

Do první kategorie hrozeb spadají situace, kdy autor knihovny buďto poskytuje vlastní kryptografický algoritmus, který byl záměrně navržen tak, aby šel autorem prolomit (taková hrozba je ale spíš zanedbatelná, protože zadní vrátka mají za cíl být pokud možno nedetekovatelná a~obrana proti takové hrozbě je triviální), nebo implementuje standardní kryptografický algoritmus způsobem, který navenek vypadá neodlišitelně od bezpečné implementace, ale jeho vnitřní fungování je upraveno tak, aby dávalo autorovi možnost kryptografii nějakým způsobem kompromitovat.

Příkladem implementace standardního algoritmu, který se dá takto ``kleptograficky'' upravit, je generování klíčů pro asymetrický algoritmus RSA, kdy zlomyslný vývojář takové implementace může prvočísla místo náhodného generování konstruovat specifickým způsobem, který mu (a~pouze jemu) později dovolí triviálně jejich součin faktorizovat\footnote{Jedna taková konstrukce je popsaná v~\cite{crypto-backdoors}.}. Dalším kryptografickým primitivem, které lze poměrně snadno a~úspěšně zmanipulovat, je generátor pseudonáhodných čísel. Takové implementace nicméně často spoléhají na složité a~neefektivní konstrukce, takže se dá alespoň částečně očekávat, že v~populárním open-source projektu by byly brzo odhaleny.~\cite{crypto-backdoors}

\subsubsection{Zadní vrátka v kryptografických API}

Do druhé kategorie hrozeb spadají situace, kdy autor knihovny korektně implementuje veřejně publikovaný a~odborníky přijímaný kryptografický standard (nebo takovou open-source implementaci využije jakožto závislost), ale v~některých konkrétních situacích záměrně použije slabé parametry nebo algoritmy a~tím kompromituje bezpečnost aplikací, které na jeho knihovně závisejí. V~takové situaci může ale být obtížné rozeznat, jestli autor takovou slabinu do kódu přidal úmyslně, nebo byla zapříčiněna jeho neznalostí nebo nedbalostí. Z~tohoto důvodu se domníváme, že nemá příliš dobrý smysl rozlišovat mezi úmyslnou sabotáží knihovny a~vnesením zranitelného kódu z~nedbalosti, a~budeme proto v~tomto textu oba případy považovat za tutéž hrozbu, kterou popíšeme v~sekci~\ref{zranitelna-impl}.

\subsubsection{Obrany proti zadním vrátkům}

Klíčovými žádoucími vlastnostmi zadních vrátek jsou jejich nedetekovatelnost a~popiratelnost\footnote{Pro jejich autora je žádoucí, aby se při případném nařčení mohl odvolat na to, že něco přehlédl nebo udělal chybu.}, což činí jejich identifikaci značně problematickou. Pokud se vývojáři softwaru obávají možnosti, že použijí takto zmanipulovanou implementaci, mají přesto několik možností.

Jednou z~nich je použít knihovnu, která je dostatečně široce používaná a~kterou zároveň používají kredibilní organizace. Nevýhodou takového přístupu je, že nemusí vždy být zcela zřejmé, které organizace jsou kredibilní; např.\ jinak dosti pozitivně přijímaný americký Národní institut standardů a~technologie (National Institute of Standards and Technology, NIST) měl podle tajných dokumentů uniklých v~roce~2013 do pseudonáhodného generátoru Dual Elliptic Curve Deterministic Random Bit Generator (DUAL\_EC\_DRBG) takový backdoor umístit~\cite{crypto-backdoors}.

Další možností je v~aplikaci použít dvě různé implementace a~jejich výstupy zkombinovat, to znamená např.\ použít dva různé generátory pseudonáhodných posloupností a~jejich výstupy kombinovat operací XOR~\cite{crypto-backdoors}. V~případě šifrování přichází v~úvahu otevřený text zašifrovat sériově dvakrát (tj.~dvěma různými implementacemi, s~dvěma různými zdroji náhodnosti klíče, případně i~dvěma odlišnými šiframi)~\cite{snowden2019permanent}. Takový přístup se spoléhá na to, že pravděpodobnost existence zadních vrátek vytvořených jedním aktérem ve dvou různých šifrách, CSPRNG, atd., nebo jejich implementacích, je extrémně malá.

\subsection{Zranitelná implementace knihovny}
\label{zranitelna-impl}

Další hrozbu pro bezpečnost knihovny, potažmo aplikací, které na ní závisí, představuje přijetí zranitelného kódu (ať už úmyslně, nebo z~nedbalosti). I~správci projektů, kteří nemají žádné zlé úmysly, mohou vystavit uživatele knihovny nebezpečí, pakliže nebudou dostatečně důsledně řídit proces přispívání do kódu a~udržovat jeho kvalitu a~tím dovolí zlomyslným aktérům (nebo nedostatečně kompetentním vývojářům) přidat do knihovny zranitelný nebo nekvalitní kód.

\subsection{Zranitelné použití knihovny uživatelem}

Jak jsme již nastínili v~předchozí kapitole, i~implementace kryptografie, které jsou samy o~sobě bezpečné, jsou často aplikačními vývojáři používány nebezpečným způsobem. Při posuzování bez\-peč\-nos\-ti knihoven je proto potřeba uvažovat i~aspekt použitelnosti, tedy hrozbu, že vývojáři knihovny například špatným návrhem rozhraní, nevhodnou volbou výchozích hodnot a/nebo dokumentací knihovny uživatele nepřímo navedou k~tomu, že kryptografii použijí špatně a~vnesou tím do svého programu zranitelnost.

\section{Přehled zkoumaných knihoven}

Před samotnou analýzou stručně představíme knihovny vybrané pro bližší zkoumání. Při výběru knihoven byly zohledněny různé oblasti našeho zájmu, zejména různé programovací jazyky (nízká a~vysoká úroveň abstrakce jazyka, slabé a~silné typování) a~různé přístupy k~návrhu rozhraní knihovny.

\subsection*{OpenSSL}

OpenSSL, jedna z~nejstarších a~pravděpodobně i~historicky nejpoužívanějších kryptografických knihoven, byla vybrána především jako výchozí bod pro porovnání s~ostatními knihovnami. Je napsaná v~programovacím jazyce C a~vyvíjená už od roku~1998. Po více než čtvrtstoletí své existence nasbírala přes 250 různých CVE --- zdaleka nejvíc ze všech open-source kryptografických knihoven~\cite{nist-nvd}.

\subsection*{libgcrypt}

Knihovna libgcrypt je součástí projektu GNU Privacy Guard (GnuPG), populární open-source implementace specifikace OpenPGP. Knihovna poskytuje implementace nízkoúrovňových kryptografických algoritmů napsané v~jazyce C. Je široce používaná mimo jiné v~linuxovém ekosystému: Na standardní distribuci Ubuntu 23.10 na ní závisí až 192 balíčků, mezi nimi např.\ systemd, gnome-keyring nebo openvpn\footnote{Zjištěno příkazem \texttt{apt-cache rdepends libgcrypt20}.}.

\subsection*{rustls}

Knihovna rustls implementuje protokol TLS, resp.\ jeho bezpečné verze TLS~1.2 a~TLS~1.3, a~dává si za cíl být moderní alternativou k~OpenSSL. Kód knihovny je napsaný v~paměťově bezpečném jazyce Rust a~knihovna zároveň skrze \emph{foreign function interface} (FFI) poskytuje API kompatibilní s~jazykem C. Její první verze byla vydána v~roce~2016, i~přes své ``mládí'' je dnes ale používána mnoha projekty a~organizacemi. Registr Rust balíčků \url{https://crates.io} eviduje 712 balíčků závisejících na rustls, mezi nimi de~facto standardní Rust balíčky implementující HTTP klienty (reqwest), HTTP servery (hyper) nebo DNS (trust-dns-proto) čítající desítky milionů stažení\footnote{Viděno 2024-03-30.}.

\subsection*{ring}

Knihovna ring implementuje primitivní kryptografické algoritmy v~kombinaci jazyků Rust (25~\% kódu), C (30~\% kódu) a~assembler (39~\% kódu). Její kryptografický kód vychází z~knihovny BoringSSL\footnote{BoringSSL je open-source kryptografická knihovna založená na kódu z~OpenSSL, kterou pro své vlastní potřeby vyvíjí společnost Google.} a~jejím cílem je poskytovat Rust API, které bude ``\textit{jednoduché použít správně a~složité použít špatně}''~\cite{ringgithub}. V~ekosystému jazyka Rust jde o~de~facto standardní kryptografickou knihovnu, lze ji však použít i~z~jiných jazyků prostřednictvím FFI rozhraní. První veřejná verze knihovny byla vydána v~roce 2016. Od roku 2023 ke knihovně ring existuje FIPS-certifikovaná\footnote{FIPS~140-2 a~FIPS~140-3 jsou certifikace kryptografických algoritmů od amerického NISTu, které mimo jiné umožňují kryptografickým implementacím být použity v~systémech spadajících pod správu federální vlády USA.} alternativa implementující stejné rozhraní, totiž knihovna aws-lc-rs od společnosti Amazon Web Services.

\subsection*{cryptography.io}

Knihovna cryptography si dává za cíl být standardní kryptografickou knihovnou pro jazyk Python~\cite{pycagithub}. Poskytuje vysokoúrovňové API pro symetrické autentizované šifrování (modul ``Fernet'') a~validaci X.509 certifikátů, zároveň však dává uživateli přístup i~k~nízkoúrovňovým kryptografickým primitivům prostřednictvím modulu ``hazmat'' (\textit{hazardous materials}). Knihovna neimplementuje protokol TLS --- nejspíš proto, že v~jazyce Python je zahrnutý do standardní knihovny~\cite{pythontls}. Je napsaná v~Pythonu (76~\% kódu) a~Rustu (24~\% kódu), závisí na OpenSSL a~vystavuje API v~jazyce Python a~C. Její první verze byla vydána v~roce 2015.

\subsection*{PyCryptodome}

PyCryptodome je oproti ``cryptography'' o~něco starší kryptografická knihovna pro jazyk Python. Vznikla v~roce~2014 jako náhrada za neudržovanou a~zranitelnou knihovnu PyCrypto, která byla zároveň proslulá svým špatným návrhem, nedostatečnou podporou pro moderní algoritmy a~nebezpečnými výchozími hodnotami~\cite{comparing2017}. Cílem bylo poskytnout stávajícím uživatelům PyCrypto jednoduchý způsob, jak přejít na bezpečnější kryptografickou implementaci, a~je proto navzdory svému relativnímu ``mládí'' poměrně hodně svázaná zpětnou kompatibilitou. Autor projekt popisuje jako ``\textit{soběstačnou knihovnu nízkoúrovňových primitiv}''~\cite{pycryptodome}, její implementace je psaná v~Pythonu (55~\%) a~C (45~\%).

\section{Organizačně-technické procesy a kvalita kódu}

První z~oblastí našeho zájmu při zkoumání knihoven je organizace jejich vývoje, tedy především otázka toho, kdo knihovnu spravuje a~financuje, komu je dovoleno přispívat do kódu, jakým způsobem je nový kód revidován nebo jak projekt reaguje na bezpečnostní incidenty. S~tím úzce souvisí i~pokyny pro přispívání a~návody na formátování kódu.

Jednotlivé knihovny se značně liší mírou sdílnosti ohledně zmíněných procesů. Zatímco Open\-SSL na svých webových stránkách~\cite{openssl-web} detailně popisuje svoje organizační struktury (včetně seznamu jejich členů), požadavky na přispěvatele, pokyny pro nahlašování nalezených zranitelností a~politiky týkající se reakce na ně, o~autorovi/správci knihovny PyCryptodome oproti tomu nevíme téměř nic a~o~autorech cryptography.io a~ring jen velmi málo.

\subsection{Postup a použité nástroje}

Při rešerši dostupných informací lze vyjít především z~oficiálních zdrojů dané knihovny, tj.~we\-bo\-vých stránek, repositáře s~kódem, dokumentace, mailing listů, apod. Máme-li štěstí, dočteme se v~těchto zdrojích o~krocích, které projekt činí k~zabezpečení procesu vývoje a~zamezení vzniku zranitelností. V~některých případech ale informace zcela chybí nebo jsou neúplné.

Chceme-li si v~takovém případě udělat představu alespoň o~počtu vývojářů a~míře, ve které do kódu přispívají, můžeme se pokusit data vytěžit z~verzovacího systému. V~případě knihoven zkoumaných v~této práci je takový postup docela dobře proveditelný díky tomu, že repositáře s~jejich kódem jsou umístěné (nebo alespoň zrcadlené) na platformě GitHub, která pro získávání informací o~příspěvcích do kódu poskytuje webové API. Za tímto účelem byl během tohoto výzkumu vytvořen primitivní skript, který taková data o~příspěvcích umožňuje z~repositářů těžit. Jeho kód je k~dispozici na přiloženém médiu v~adresáři \texttt{appendices/commitfetch}.

Metriky popisující složitost kódu, jako je třeba průměrný počet řádků na soubor, maximální stupeň zanoření kódu, apod., mají tu výhodu, že se díky svému kvantitativnímu charakteru dají snadno automaticky měřit\footnote{V~případě jazyka C například nástrojem \texttt{cqmetrics}.}. Nevýhoda takového přístupu ale spočívá v~tom, že neexistují žádné univerzálně přijímané hranice pro bezpečné, resp.\ nebezpečné hodnoty jednotlivých metrik. Software, který tyto metriky počítá, navíc nemusí brát v~potaz různá specifika projektu, dokumentační komentáře nebo soubory, které obsahují pouze deklarace a~ne samotnou implementaci funkcí. V~neposlední řadě tyto metriky nezachytí důležité kvalitativní aspekty kódu, jako je jeho srozumitelnost, použití vhodných identifikátorů, apod. Z~těchto důvodů se nám nejeví jako dostatečně přínosné takový přístup použít. Kvalitu kódu lze kromě povrchové manuální revize kódu odhadnout třeba na základě přítomnosti (a~použitých technik) testů nebo začlenění průběžné integrace (\textit{continuous integration}, CI) do vývoje projektu.

\subsection{Výsledky}

\subsubsection*{OpenSSL}

Knihovnu OpenSSL zaštiťuje organizace OpenSSL Software Foundation. Vývoj projektu řídí dvě komise: První z~nich, Open\-SSL Management Committee (OMC), určuje vy\-so\-ko\-ú\-rov\-ňo\-vé směřování projektu a~rozhoduje o~ma\-na\-žer\-ských otázkách; Open\-SSL Technical Committee (OTC) má hlavní slovo v~technických zá\-le\-ži\-tos\-tech (včetně přispívání do kódu)~\cite{openssl-bylaws}. Z~hlediska financování se OpenSSL spoléhá na dary od sponzorů a~příjmy z~poskytování tzv.~\textit{support contracts} neboli komerční podpory na míru zákazníkům~\cite{openssl-donations}.

Klíčový institut, který OpenSSL používá, je \textit{committer} (přispěvatel). Tímto termínem projekt OpenSSL označuje status vývojáře, který může provádět netriviální změny v~kódu\footnote{Triviální změny jsou např.\ opravy gramatických nebo typografických chyb, jednořádkové opravy chyb nebo změny ve formátování (\emph{whitespace changes}). Na triviálnosti změny se musí shodnout autor se všemi, kdo změnu revidují.~\cite{openssl-committerpolicy}} a~schvalovat úpravy ostatních přispěvatelů. Status přispěvatele lze získat od OMC zpravidla na doporučení OTC a~může být kdykoli revokován na základě hlasování~\cite{openssl-committerpolicy}. Přispěvatelé jsou vázáni smlouvou \textit{Contributor License Agreement} (CLA), kolektivně zodpovídají za udržování kódu a~je od nich požadována pravidelná aktivita v~podobě autorství nebo revize alespoň 1~příspěvku (\textit{commitu}) za 2~čtvrtletí. V~současnosti má tento status 18~vývojářů~\cite{openssl-committerlist}.

Oficiální zdroje knihovny~\cite{openssl-committerpolicy} popisují taktéž proces revize a~schvalování změn v~kódu: Změny v~kódu musí být revidovány a~schváleny alespoň dvěma přispěvateli; alespoň jeden z~nich musí být členem OTC a~ani jeden z~recenzentů (\textit{reviewers}) nesmí být autorem kódu. Webová stránka dále poskytuje návod pro nahlášení zranitelností, popisuje bezpečnostní nedostatky knihovny a~deklaruje způsob, kterým jsou objevené zranitelnosti opravovány a~aplikovány záplaty. Vývoj knihovny je organizován prostřednictvím platformy GitHub.

Knihovna OpenSSL je napsaná v~jazyce C, který je proslulý svou náchylností k~bezpečnostně kritickým chybám. Projekt využívá funkce CI platformy GitHub a~s~každou změnou kódu spouští automatickou sadu testů, přičemž zároveň měří pokrytí kódu, které se v~době vzniku této práce pohybuje na úrovni 67~\%~\cite{openssl-codecov}, a~je též fuzzován prostřednictvím projektu OSS Fuzz~\cite{openssl-fuzz}. Knihovna splňuje certifikaci FIPS~140-2~\cite{openssl-fips} a~vlastní odznak OpenSSF Best Practices~\cite{openssl-openssf}, z~čehož můžeme soudit, že její vývoj probíhá bezpečným způsobem a~certifikované algoritmy jsou implementovány správně. Bohužel nám to ale nic neříká o~tom, jestli je knihovna pro uživatele srozumitelná nebo jestli je navádí k~bezpečnému použití.

\subsubsection*{libgcrypt}

Knihovna libgcrypt spadá pod organizaci projektu GnuPG. Ten spravuje skupina pěti správců uvedených na webové stránce projektu~\cite{gnupg-people}, někteří z~nich jsou navíc zaměstnanci společnosti g10\textsuperscript{code} a~vývoji se věnují na plný úvazek. Finance projekt GnuPG od roku 2022 čerpá (podobně jako OpenSSL) z~prodeje komerční podpory k~produktu GnuPG VS-Desktop, dříve byl financován sponzorskými dary~\cite{gnupg-new-future}.

Vývoj knihovny na rozdíl od OpenSSL neprobíhá na dedikované platformě, ale pro\-střed\-nic\-t\-vím veřejného \textit{mailing listu} (tj.~hromadné e-mailové komunikace). Samotný repositář s~kódem je přístupný skrz webovou stránku projektu. Projekt nijak nepopisuje požadavky na přispěvatele do kódu --- kdokoli může požádat o~to, aby byl do mailing listu přidán, navrhované změny v~kódu jsou revidovány nejspíš\footnote{Knihovna libgcrypt na rozdíl od OpenSSL nepopisuje proces, kterým je kód revidován. Informace, které podáváme v~tomto textu, jsou založené na nesystematické analýze archivů zpráv z~mailing listu.} na individuální bázi na základě obsahu spíš než autorství.

Projekt GnuPG splňuje požadavky OpenSSF Best Practices~\cite{gnupg-openssf} a~knihovna libgcrypt nabízí mód kompatibilní s~certifikací FIPS~140-3. Z~tohoto hlediska tedy můžeme knihovny libgcrypt a~OpenSSL prohlásit za srovnatelné, hlavní rozdíl mezi jejich organizací spočívá v~dostupnosti informací o~procesech souvisejících s~revizí a~přijímáním nového kódu.

Pozoruhodným faktem je, že navzdory podobnému stáří obou ``céčkových'' knihoven má lib\-g\-crypt v~databázi CVE pouze 15 záznamů, zatímco OpenSSL jich má 257. To může souviset se skutečností, že OpenSSL je co do počtů řádků kódu zhruba 4krát větší než libgcrypt~\cite{cloc-openssl-libgcrypt} a~na rozdíl od libgcrypt implementuje i~protokol SSL/TLS, definitivně rozhodnout o~skutečných příčinách tohoto rozdílu ale navzdory vší snaze nedokážeme --- potenciálních vysvětlujících proměnných je zkrátka příliš mnoho.

\subsubsection*{rustls}

Knihovna rustls je vyvíjená na platformě GitHub~\cite{rustls-gh}, kde jsou zároveň uvedeny všechny informace ohledně její organizace, struktury a~financování. Na rozdíl od předchozích dvou knihoven není rustls registrovaná v~projektu OpenSSF Best Practices a~tento odznak proto nevlastní; z~dostupných informací nicméně vyplývá, že kritéria pro jeho získání vesměs splňuje\footnote{V~průběhu psaní tohoto textu jsme se proto rozhodli správcům adopci odznaku navrhnout. Návrh je veřejný a~přístupný skrze URL \url{https://github.com/rustls/rustls/issues/1901} [cit. 2024-04-17].}.

Projekt je spravován projektovým manažerem a~trojicí vývojářů, dva z~nichž jsou full-time zaměstnanci iniciativy Prossimo, která je součástí neziskové organizace Internet Security Research Group a~usiluje o~``\textit{přechod internetové infrastruktury kritické pro bezpečnost na paměťově bezpečné implementace}''~\cite{prossimo}. Způsob vyvíjení kódu je do velké míry určen používanými nástroji --- diskuze nad změnami v~kódu, návrhy na nové funkce, apod.\ probíhají na GitHubu, stejně jako nahlašování zranitelností, které GitHub podporuje formou tzv.~\textit{security advisories}. Přestože od svého vzniku rustls čítá pouze 1~CVE\footnote{CVE-2019-15541.}, popisuje detailně politiky pro reakce na nahlášené zranitelnosti: Kromě samotné opravy, která je navíc zpětně aplikována na verze ne starší než 2~roky, mají být připraveny regresní testy a~zranitelnost nahlášena do databáze RustSec Advisory Database\footnote{RustSec Advisory Database~\cite{rustsec} je databáze zranitelností pokrývající všechny balíčky publikované pro\-střed\-nic\-tvím služby \url{https://crates.io}. Databáze je spravována oficiální pracovní skupinou jazyka Rust pro bezpečnost kódu (Rust Secure Code WG) a~je integrována přímo do standardního nástroje \textit{cargo}.}.

Knihovna rustls neklade žádné konkrétní požadavky na autory nových příspěvků kódu, podle dostupných informací může změnu navrhnout kdokoli. ``Readme'' projektu doporučuje nejprve vytvořit \textit{issue} a~chystanou změnu zkonzultovat se správci projektu; dále obsahuje pokyny ohledně velikosti jednotlivých změn (\textit{commitů}), praktik při psaní kódu, nutnosti testů, atd. Poslední slovo v~otázkách přijímání nového kódu mají správci projektu, přičemž na úrovni GitHub repositáře je vyžadována před schválením nového kódu (tzv.~\textit{pull requestu}, zkr.~PR) revize od alepoň jednoho člena s~rolí \textit{reviewer}.~\cite{rustls-gh}

\subsubsection*{ring}

Knihovna ring je z~hlediska organizace poměrně netypická --- nespravuje ji totiž tým vývojářů, jako v~případě rustls, ani obchodní nebo nezisková společnost, jako v~případě OpenSSL a~libgcrypt. Vlastníkem GitHub repositáře, jediným správcem knihovny a~zároveň nejaktivnějším vývojářem (z~hlediska počtu commitů za rok 2023) je uživatel Brian Smith~\cite{ringgithub}. Na svém profilu na platformě GitHub odkazuje na svůj blog, na kterém od roku 2015\footnote{Zjištěno pomocí Wayback Machine, \url{https://web.archive.org/web/20240000000000*/briansmith.org} [cit. 2024-04-16].} píše o~různých kryptografických tématech; na blogu i~na GitHub profilu ale chybí jakékoli informace o~samotném autorovi, jeho afilaci, kompetencích, apod.

Použitím technik \textit{open-source intelligence} (OSINT) se nám podařilo zjistit, že tento Brian Smith byl alespoň v~období cca~2010--2014 zaměstnancem společnosti Mozilla. Tomu nasvědčuje pracovní e-mailová adresa v~dřívější verzi blogu~\cite{briansmith-email} a~ticket v~systému Bugzilla~\cite{briansmith-bugzilla} z~roku 2010, ve kterém B.~Smith s~touto e-mailovou adresou úspěšně žádá o~přístup pro zaměstnance. V~souladu s~tímto zjištěním je i~archivovaný repositář na jeho GitHub profilu, který má obsahovat kód pro validaci certifikátů X.509 z~prohlížeče Mozilla Firefox~\cite{briansmith-firefox}, nebo také komentář stejnojmenného uživatele na sociální síti Reddit, který tvrdí, že pracuje na implementaci protokolu SSL v~prohlížeči Mozilla Firefox~\cite{briansmith-ssl}. Otázkou ale stále zůstává, jakou motivaci pro vývoj knihovny ring má její autor v~současnosti a~proč o~organizaci projektu poskytuje tak málo informací.

Ani ohledně procesů přispívání a~revize kódu není autor knihovny příliš sdílný. Historie repositáře ukazuje, že často změny v~kódu navrhuje i~schvaluje sám autor. V~``readme'' projektu je zmíněno, že je do projektu možné přispívat skrze PR, kromě požadavků na kompatibilní licenci však nejsou formulovány žádné konkrétní pokyny, požadavky na kód, apod. Za rok 2023 do kódu knihovny přispělo celkem 52~autorů, 33~z~nich pouze jedním příspěvkem; přes 90~\% všech příspěvků pocházelo od B.~Smitha a~autorů knihovny BoringSSL, ze které ring pravidelně slévá kód.

Projekt ring podle oficiálních záznamů OpenSSF splňuje požadavky odznaku Best Practices kvůli údajné chybějící statické a~dynamické analýze pouze na 82~\%, tento záznam byl ale vytvořen v~roce~2016 a~od té doby nebyl aktualizován.

\subsubsection*{cryptography.io}

Knihovna cryptography je vyvíjena skupinou Python Cryptography Authority (PyCA) na platformě GitHub. Navzdory názvu této skupiny nejde o~právnickou osobu se smluvním vztahem k~Python Software Foundation, ale jednoduše o~skupinu aktivních vývojářů z~open-source komunity. Jeden z~členů skupinu charakterizuje takto:

\blockquote{``\textit{Speaking as one of the members of the PyCA, no, there is no official licensing body and we are not licensed. [...] The Python Cryptographic Authority aspires to be the primary resource for Python developers needing cryptographic libraries, but our authority is derived solely from developer opinion of the quality of our software.}''~\cite{pyca-so}}

Není ale zřejmé, jaké jsou nároky na členství v~této skupině nebo jakým způsobem je knihovna cryptography (a~další, např.\ pyopenssl, pynacl nebo bcrypt) skupinou PyCA spravována. Webová stránka knihovny~\cite{pyca-web} zmiňuje pouze mailing list, IRC chat a~odkaz na GitHub repozitář, profil PyCA na GitHubu obsahuje pouze seznam členů a~odkazy na jednotlivé repositáře.

Oficiální stránky knihovny na druhou stranu popisují ``přísnou politiku'' pro přijímání kódu kvůli ``devastujícím následkům'' nesprávné implementace kryptografie. Kód nesmí do projektu přijmout nikdo z~jeho autorů, nové příspěvky do kódu musí doprovázet testy se 100\% pokrytím přidávaného kódu a~všechny testy musí procházet na 100~\%. Dokumentace knihovny zároveň obsahuje zvláštní sekci věnovanou bezpečnosti. Kanálem pro nahlašování zranitelností jsou podobně jako u~předchozích knihoven GitHub security advisories. Za zmínku stojí poměrně široká definice bezpečnostního problému, kterým se cryptography zavazuje zabývat:

\blockquote{``\textit{What is a~security issue? Anytime it’s possible to write code using cryptography’s public API which does not provide the guarantees that a~reasonable developer would expect it to based on our documentation. [That] means the scope of what we consider a~vulnerability is broad, and we do not require a~proof of concept or even a~specific exploit, merely a~reasonable threat model under which cryptography could be attacked.}''~\cite{pyca-security}}

Knihovna cryptography není vedená v~projektu OpenSSF Best Practices, přestože většinu kritérií splňuje. Informace z~oficiálních zdrojů celkově tvoří dojem projektu, který bezpečný vývoj bere vážně, jeho důvěryhodnost ohrožuje především neznámá organizace a~motivace členů skupiny PyCA.

\subsubsection*{PyCryptodome}

Podobně jako ring je knihovna PyCryptodome vyvíjena jediným vývojářem, který je na Git\-Hubu registrovaný pod jménem Helder Eijs~\cite{pcd-gh}. Kromě jeho uživatelského jména @Legrandin (pravděpodobně jde o~referenci na literární postavu Marcela Prousta), profilového obrázku zobrazujícího nizozemského novokřtěnce Jana z~Leidenu a~e-mailové adresy, které spolu se jménem naznačují potenciálně nizozemskou národnost, se nám o~něm žádné informace získat nepodařilo.

Knihovna je vyvíjena prostřednictvím GitHubu a~mailing listu. Projekt podává pouze minimální informace o~pravidlech přispívání do kódu (pouze je vyžadována přítomnost testů) a~proces revize kódu není nijak popsán --- z~praktického hlediska změny navrhuje a~potvrzuje sám H.~Eijs. Za rok 2023 do kódu přispělo 18~uživatelských účtů, z~nich 14 pouze jediným příspěvkem; autorem 94 z~celkových 124~změn v~kódu byl vlastník repositáře. Podobně v~projektu chybí informace o~procesu reakce na případné zranitelnosti.

Z~hlediska důvěryhodnosti z~našeho pohledu knihovna PyCryptodome výrazně zaostává za ostatními, které v~tomto textu zkoumáme. Neznáme identitu a~motivaci správce projektu, projekt o~sobě neposkytuje dostatek informací, které by potenciálního uživatele přesvědčily o~bezpečnosti knihovny, a~pravděpodobně nedochází k~žádné křížové kontrole nového kódu někým jiným, než je jeho autor. Projekt mimo jiné neusiluje o~získání odznaku OpenSSF a~nesplňuje některá jeho základní kritéria. Částečně to lze ospravedlnit původem projektu --- PyCryptodome především slouží jako (jediná) bezpečnější náhrada zastaralé knihovny PyCrypto a~pravděpodobně si proto neklade za cíl získávat nové uživatele.

\section{Dokumentace a návrh API} \label{analyza-dok-a-navrh}

Dalším aspektem kryptografických knihoven, kterým --- jak vyplynulo z~literární rešerše --- má smysl se zabývat, je kvalita dokumentace knihovny a~návrh jejího kognitivního rozhraní.

\subsection{Postup} \label{analyza-beznepouziti}

Při analýze návrhu API je naším cílem zohlednit především jednoduchost použití API ``prů\-měr\-ným'' vývojářem bez hlubších znalostí kryptografie, dále úroveň bezpečnosti, kterou takové přímočaré použití dosáhne, ale zároveň i~přítomnost pokročilejších funkcí a~mechanismů pro přizpůsobení parametrů kryptografických operací. Návrh API přirozeně do velké míry souvisí s~dokumentací, která API vysvětluje (případně i~demonstruje jeho použití) a~slouží tradičně jako primární zdroj informací o~správném použití knihovny pro její uživatele.

Jedním způsobem, kterým lze získat představu o~přednostech a~úskalích rozhraní knihovny, je ručně projít deklaraci všech funkcí, které knihovna nabízí, a~porovnat je s~praktikami bezpečného návrhu popsanými v~kapitole~\ref{pouziti}. To ale může být poměrně zdlouhavý, nezajímavý a~u~větších knihoven s~netriviálním počtem funkcí i~náročný úkol. Jako přijatelné řešení se proto jeví vybrat jeden konkrétní scénář, který by knihovna měla být schopná řešit, a~zkusit tento scénář minimalistickým způsobem implementovat přímo v~kódu. Mezi běžné scénáře, které by mohl uživatel knihovny chtít realizovat, je například ochrana důvěrnosti a~integrity informací pomocí hesla, podepsání dat soukromým klíčem, uložení hesla do databáze a~jeho pozdější ověření nebo třeba navázání TLS spojení.

Pro analýzu API většiny námi vybraných knihoven jsme zvolili scénář, kdy chceme (autentizovaně) zašifrovat soubor pomocí hesla --- to zahrnuje použití přinejmenším funkce pro odvození klíče, symetrické šifry a~funkce MAC (případně autentizované šifry) a~serializace výstupu do souboru. Výjimkou je knihovna rustls, která samotné šifrování nenabízí, proto v~jejím případě budeme chtít navázat TLS spojení se vzdáleným serverem. Obecně je v~tomto bodě naší snahou použít ten nejjednodušší způsob, který knihovna pro dosažení daného cíle nabízí, neboť se tak dá velmi snadno odhadnout úroveň expertízy, kterou knihovna od uživatele očekává. Výsledný kód implementující tyto scénáře s~použitím každé knihovny je k~dispozici na přiloženém médiu v~adresáři \texttt{appendices/lib-examples}.

Mezi klíčové aspekty kvality dokumentace, které budeme u~jednotlivých knihoven zkoumat, patří především její úplnost, přehlednost a~možnost jednoduché navigace/vyhledávání v~ní. Od kvalitní dokumentace zároveň očekáváme, že bude vysvětlovat význam všech parametrů a~jejich důsledků pro bezpečnost, zřetelně odliší bezpečné algoritmy od prolomených a~zároveň poskytne bezpečné a~realistické ukázky kódu alespoň pro několik základních scénářů použití knihovny.

\subsection{Výsledky}

\subsubsection*{OpenSSL}

Návrh API knihovny OpenSSL je značně limitovaný zpětnou kompatibilitou, jednoduchostí jazyka C a~velikostí knihovny. Její API je sice mocné a~flexibilní, vykazuje ale významné nedostatky především z~hlediska přehlednosti a~srozumitelnosti: Jen v~``modulu'' pro symetrické šifrování (EVP\_CIPHER) existuje 94~funkcí~\cite{openssl-evp-encryptinit}, přičemž z~jejich názvů není na první pohled příliš dobře poznat, které z~nich zajišťují běžné operace a~které jsou specializované. K~odlišení rozšířených verzí starších funkcí knihovna používá v~jejich názvech přípony a~čísla (např.\ \texttt{\_ex}, \texttt{\_ex2}, \dots), což může být pro nové uživatele matoucí a~někdy zcela bránit pochopení účelu funkce (např.\ u~funkce \texttt{EVP\_CIPHER\_get0\_name} není vůbec jasné, co znamená číslo~0 za slovem ``get''). Pro bezpečnost zdaleka největším nedostatkem rozhraní OpenSSL je ale skutečnost, že nedává implementaci možnost zkontrolovat velikosti parametrů, které jí uživatel předá (např.\ délku klíče, IV, apod.). Pokud paměť pro ně uživatel alokuje špatně, knihovna neoznámí chybu, ale bude s~nimi pracovat, jako kdyby byly tak veliké, jak předpokládá. Takový přístup \emph{dramaticky} zvyšuje riziko vzniku nejen kryptografických, ale i~paměťových zranitelností.

Rozhraní OpenSSL pracuje s~kryptografií na velmi nízké úrovni a~neexistují v~něm jakékoli abstrakce pro běžné kryptografické scénáře. Uživatel knihovny musí sám vědět, jaké algoritmy a~s~jakými parametry chce použít, a~ani tehdy nebude použití knihovny jednoduché. Navíc knihovna do jisté míry trpí svou snahou být naprosto obecná: Například funkci pro odvození klíče z~hesla je potřeba místo standardního způsobu předat parametry v~podobě pole obecných struktur \texttt{OSSL\_PARAM}. Dalším příkladem nepřívětivého rozhraní je použití textových řetězců pro identifikaci algoritmů nebo krypt.\ primitiv. Na jednu stranu určitě existuje šance, že taková uživatelská nepřívětivost případné neznalé uživatele od použití knihovny odradí, na druhou stranu je stejně tak možné, že se uživatel v~takových situacích obrátí k~nedůvěryhodným zdrojům a~knihovnu použije zranitelným způsobem. Z~tohoto pohledu v~žádném případě nelze knihovnu OpenSSL doporučit k~použití ``řadovému'' vývojáři bez patřičné bezpečnostní expertízy.

Dalším velkým nedostatkem knihovny OpenSSL je její mechanismus pro ošetřování chyb, jejž obstarávají číselné návratové hodnoty (\texttt{int}), případně neplatné ukazatele (\texttt{NULL}). Programátor si tak musí sám uvědomit, že je potřeba chyby kontrolovat. (Jazyk C kromě tvrdého ukončení programu nemá žádný mechanismus, kterým by mohl zaručit, že programátor chybové stavy ošetří.) Z~hlavičky funkce, která tento mechanismus používá, není zřejmé, že může selhat a~že návratovou hodnotou je indikátor chyby a~nikoli celé číslo reprezentující nějakou skutečnou veličinu (kterou programátor snadněji odignoruje). Souvisejícím problémem, se kterým se dlouhodobě potýká dokonce i~vnitřně samotná knihovna, jak ilustrují zranitelnosti CVE-2008-5077~\cite{cve-2008-5077} nebo CVE-2021-4044~\cite{cve-2021-4044}, je nekonzistence v~tom, které hodnoty indikují úspěch a~které chybu.

Rozhraní poskytované knihovnou OpenSSL je slabě typované. Používá sice struktury jako \texttt{EVP\_CIPHER}, \texttt{EVP\_CIPHER\_CTX} a~podobné, ty jsou však používány pro uchování vnitřního stavu používaného implementací a~neposkytují pro uživatele žádnou užitečnou abstrakci, naopak je potřeba se postarat o~jejich inicializaci, uvolňování nebo správné pořadí volání funkcí měnící jejich vnitřní stav. V~neposlední řadě na základě rozhraní knihovny nelze nijak rozeznat bezpečné algoritmy/konfigurace od těch zastaralých a~zranitelných.

Dokumentace knihovny OpenSSL je dalším důvodem, proč by její doporučení bylo činem šílenství. Knihovna je dokumentována unixovými manuálovými stránkami, které jsou zároveň dostupné na webových stránkách projektu. To činí jakoukoli přehlednost nebo snadnou navigovatelnost značně problematickou. Dále dokumentace OpenSSL nijak nerozlišuje bezpečnost jednotlivých algoritmů ani nevysvětluje význam parametrů a~předpokladů, které na ně klade. Dokumentace sice obsahuje ukázky kódu, jejich nalezení je ale poměrně pracné a~jejich obsah přinejmenším pochybný. Další ukázky kódu lze dohledat na OpenSSL Wiki~\cite{openssl-wiki}, která věnuje o~něco větší úsilí vysvětlení jednotlivých kryptografických konceptů a~algoritmů. Jejich obsah ale rozhodně nesplňuje bezpečnost a~realismus, jak ilustruje následující ukázkový kód~\cite{openssl-wiki-example}:

\begin{lstlisting}[caption={~Ukázka použití knihovny OpenSSL z~OpenSSL Wiki},language=C]
/*
 * Set up the key and iv. Do I need to say to not hard code these in a
 * real application? :-)
 */

/* A 256 bit key */
unsigned char *key = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
                       0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
                       0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33,
                       0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31
                     };

/* A 128 bit IV */
unsigned char *iv = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
                      0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35
                    };
\end{lstlisting}

Odpovědí na autorovu řečnickou otázku je ``ano, ale to nestačí''. Pakliže chtějí správci knihov\-ny podporovat její bezpečné použití, pak musí vědět, že poskytované ukázky kódu byť jen ne\-pa\-tr\-ně působící dojmem oficiality budou jedním z~hlavních zdrojů, ze kterých uživatelé budou čer\-pat informace o~použití knihovny a~inspiraci pro svůj vlastní kód. V~tomto ohledu jsou ukázky kódu dvojsečná zbraň: Na jedné straně uživatelům významně usnadňují adopci knihovny a~mohou sloužit jako kvalitní vzdělávací prostředek, na straně druhé může v~uživateli funkční, ale nebezpečný ukázkový kód vyvolat falešný pocit bezpečí. V~předchozí ukázce je nevhodně zvo\-len především komentář, ve kterém autor poukazuje na to, že při skutečném použití klíč a~IV nemají být do kódu programu vloženy natvrdo. Z~toho totiž pro laika může plynout, že má tyto hodnoty uložit někam mimo kód a~tím problém vyřeší. Mohli bychom argumentovat, že pokud by se byl autor komentáře zdržel, bylo by prav\-dě\-po\-dob\-něj\-ší, že se uživatel pokusí vyhledat informace o~tom, jak má správně zacházet s~kryptografickým klíčem, zatímco v~současném stavu se uživatel zaměří na to, kam klíč a~IV ukládá, a~nikoli už na to, jak má vygenerovat klíč s~dos\-ta\-teč\-nou en\-tro\-pií, že má pro každou zprávu použít jedinečný IV, atd. Zajímavé je také to, že kód pro vygenerování kvalitního klíče a~IV by byl do počtu řádku kratší než ten s~pevnými tex\-to\-vý\-mi hodnotami, nedává proto smysl argumentovat tím, že si chtěl autor kódu pouze ušetřit práci. Open\-SSL Wiki je navíc zjevně zastaralá --- některé stránky nebyly aktualizovány už několik let. To je pravděpodobně zapříčiněno mimo jiné tím, že stránka uživatelům nedovoluje obsah editovat (ani v~něm navrhovat změny). Ani z~hlediska kvality dokumentace proto použití Open\-SSL není možné doporučit.

\subsubsection*{libgcrypt}

Stejně jako OpenSSL je knihovna libgcrypt implementována v~jazyce C a~její rozhraní je spíše nízkoúrovňové --- je opět ponecháno na programátorovi, aby vhodně zvolil používané algoritmy a~jejich parametry. Přesto je rozhraní libgcrypt podstatně jednodušší a~srozumitelnější než to, které poskytuje OpenSSL. Pro účely ošetřování chyb v~knihovně existuje datový typ \texttt{gcry\_error\_t}, který sice neřeší problém s~tím, že jazyk C nedokáže vynutit jeho zkontrolování, ale z~hlavičky funkce je alespoň zřetelně poznat, že návratovou hodnotou je indikátor chyby/úspěchu. Chybové kódy jsou navíc oproti OpenSSL konzistentní --- hodnota~0 vždy reprezentuje úspěch. Modul pro používání symetrických šifer má pouze 22 funkcí, které jsou navíc dobře srozumitelné a~výstižně pojmenované (například pro odvození klíče z~hesla a~soli je potřeba zavolat jednu funkci; oproti tomu OpenSSL pro dosažení stejného výsledku poskytuje ukázku kódu s~cca 10~voláními). Knihovna libgcrypt navíc nabízí i~funkci na vygenerování nonce a~její kryptografický pseudonáhodný generátor explicitně rozlišuje tři úrovně náhodnosti, nejslabší z~nichž je uživateli zpřístupněna pouze skrz zvláštní funkci --- to je v~souladu s~principem \textit{secure by default}.~\cite{gcrypt-doc}

Stejně jako OpenSSL však ani libgcrypt neposkytuje žádné abstrakce nebo silné typy obalující kryptografická primitiva a~je opět zodpovědností programátora, aby funkce knihovny volal ve správném pořadí. Volba algoritmů je implementována skrze symbolické číselné konstanty a~API knihovny nijak neupozorňuje nebo neztěžuje použití zastaralých algoritmů, které nabízí.

Dokumentace knihovny libgcrypt je obsáhlá, ale spíše technická. Od čtenáře očekává ``\textit{základní znalosti aplikované kryptografie}''~\cite{gcrypt-getting-started}. Neobsahuje žádné ukázky kódu, nevyjadřuje se (až na výjimky) k~bezpečnosti algoritmů, které dává k~dispozici (např.\ nevaruje před nebezpečnými ope\-rač\-ní\-mi módy), nevysvětluje plně smysl jednotlivých parametrů a~správný způsob jejich generování, ani nemá úvod, který by se zabýval vysvětlením kryptografických konceptů a~vysokoúrovňovým postupem pro jejich bezpečné použití.

Vyhledávání v~dokumentaci je poměrně složité. V~HTML verzi vyhledávat podle klíčových slov jednoduše nejde, o~něco lepší je vyhledávání v~PDF souboru. Otázka je, jestli si ``průměrný vývojář'' otevře PDF soubor s~dokumentací, nebo radši zadá dotaz do Googlu nebo LLM.

\subsubsection*{rustls}

Knihovna rustls díky svému úzkému zaměření pouze na TLS 1.2 a~1.3 a~vysokoúrovňovému návrhu API eliminuje mnohá rizika spojená s~použitím kryptografie. Knihovna za uživatele automaticky řeší volbu šifrovacích algoritmů, z~nichž podporuje pouze ty, které netrpí žádným bezpečnostním nedostatkem. Rozhraní knihovny je (idiomaticky pro jazyk Rust) zprostředkováno silnými typy a~abstrakcemi vynucujícími správné použití. Při implementaci jednoduchého TLS klienta potřebuje uživatel vyřešit pouze jeden technický aspekt protokolu, kterým je soubor kořenových certifikátů. Tento potenciální problém je nicméně adresován hned mezi prvními ukázkami kódu v~dokumentaci knihovny jednoduchým (a~bezpečným) řešením, které využívá balíčku \texttt{webpki-roots} poskytujícího kořenové certifikáty organizace Mozilla. Výsledný kód pro navázání TLS spojení se serverem \textit{fit.cvut.cz:443} a~poslání jednoduchého HTTP požadavku na něj má díky tomu jen jednotky řádek.

Rozhraní knihovny rustls nebezpečnému použití brání explicitním vyčleněním a~označením nebezpečných datových typů do zvláštního modulu (např.\ změnu algoritmu pro validování certifikátů serveru lze učinit pouze skrze metody speciální struktury \texttt{rustls::\allowbreak client::\allowbreak danger::\allowbreak DangerousClientConfig}). Tím dosahuje jak bezpečnosti výchozího použití, tak i~konfigurovatelnosti v~případě specifické potřeby aplikace.

Z~použití jazyka Rust vyplývá mimo jiné rigorózní mechanismus ošetřování chyb. Kód napsaný v~Rustu zpravidla využívá generického datového typu (enumerace) \texttt{Result<T,~E>} ze standardní knihovny jazyka --- funkce obsahující kód, který může selhat, vrací specializaci tohoto typu a~volající má několik možností, jak případnou chybu ošetřit. První z~nich jsou metody \texttt{unwrap()} a~\texttt{expect(\&str)}, které se pokusí ``vybalit'' návratovou hodnotu typu \texttt{T}. Pakliže obsahuje Result chybovou variantu, program je natvrdo ukončen (je vyvolána tzv.~\textit{panika}). Další možností je použití operátoru~\texttt{?}, který chybu ``vybublá'' do volající funkce. Nakonec má programátor možnost chybu zpracovat explicitně výrazem \texttt{match} nebo \texttt{if~let}, případně monadickými operacemi nad tímto typem (např.\ metody \texttt{map} nebo \texttt{and\_then}).

Dokumentace knihovny rustls je velmi kvalitní. Úvodní stránka srozumitelně vymezuje funkcionality, které rustls nabízí, zamýšlené použití knihovny, ale i~funkce, které spadají mimo její rámec. Kromě dokumentace API a~ukázek kódu je součástí dokumentace i~manuál, který podrobně popisuje návrh knihovny a~způsoby, kterými se knihovna snaží předejít zranitelnostem (tzv.~\textit{assurance case}). Zejména shrnuje nejzávažnější incidenty spojené s~SSL a~TLS v~posledních 20~letech a~popisuje mechanismy, kterými rustls těmto konkrétním druhům problémů zabraňuje.~\cite{rustls-man}

\subsubsection*{ring}

Knihovna ring implementuje nízkoúrovňové kryptografické algoritmy a~vystavuje podle svých slov API, které má být ``\textit{jednoduché použít správně a~složité použít špatně}''~\cite{ringgithub}. Uživatel stále musí vědět, jakými prostředky (krypt.\ primitivy) dosáhnout svého cíle, nemusí se ale obávat toho, že zvolí nebezpečnou konfiguraci --- knihovna ring totiž zastaralé algoritmy vůbec nenabízí. Výjimkou je hašovací funkce SHA-1, která je nicméně v~dokumentaci popsána jako zastaralá a~v~kódu explicitně označena identifikátorem \texttt{SHA1\_FOR\_LEGACY\_USE\_ONLY}.

Podobně jako rustls i~ring využívá typového systému jazyka Rust a~svoje rozhraní podává v~podobě vysokoúrovňových typů jako \texttt{OpeningKey}, \texttt{SealingKey}, \texttt{Nonce}, atd. I~přes snahu knihov\-ny o~použitelnost není ale její použití přímočaré. V~příkladě zaměřeném na šifrování souborů pomocí hesla uživatel narazí na to, že ``konstruktor'' typu \texttt{SealingKey}, který poskytuje funkce pro provedení šifrování, vyžaduje od uživatele argument implementující vlastnost\footnote{Vlastnost (\textit{trait}) je v~jazyce Rust obdobou rozhraní (\textit{interface}), případně \textit{abstraktních} nebo \textit{ryze virtuálních} tříd, v~objektově orientovaných jazycích.} \texttt{NonceSequence}, přitom knihovna žádný takový typ neposkytuje a~zcela nechává na uživateli, aby takový typ zajistil~\cite{ring-noncesequence-issue}. Alternativně může uživatel místo typu \texttt{SealingKey} použít \texttt{LessSafeKey} a~nonce generovat pro každé šifrování zvlášť sám. Narážíme zde v~jistém smyslu na stejný nedostatek, který Acar a~kol.~\cite{comparing2017} během svého experimentu identifikovali u~knihovny Keyczar a~podobných, tedy že knihovna sice svým rozhraním podporuje bezpečné použití, ale neposkytuje dostatečné podpůrné funkce pro její použití v~realistickém scénáři. Zajímavou okolností je, že již zmíněná knihovna aws-lc-rs implementaci \texttt{NonceSequence} poskytuje.

Dokumentace knihovny ring je rozdělená do sekcí po jednotlivých modulech knihov\-ny, tj.~\textit{aead}, \textit{agreement}, \textit{digest}, atd. U~některých operací knihovna poskytuje detailní ukázky kódu (např.\ ustanovení společného klíče pomocí X25519), ale například u~AEAD nebo HKDF ukázky chybí.

\subsubsection*{cryptography.io}

Knihovna cryptography svoje programátorské rozhraní rozděluje do vysoko- a~nízkoúrovňového modulu. API knihovny je flexibilní --- zkušený uživatel má možnost použít nízkoúrovňové API pro práci s~jednotlivými primitivy --- ale přesto kompaktní (např.\ proces šifrování je sloučen do jednoho volání), vysokoúrovňové API je snadno použitelné a~nevyžaduje detailní kryptografické znalosti. Jeho nevýhodou je jeho omezenost pouze na jednu specifickou konfiguraci autentizované šifry a~práci s~certifikáty. Přestože tzv.~``Fernet'' rozhraní před uživatelem skrývá použité algoritmy a~serializaci dat, tyto údaje lze v~dokumentaci dohledat. (Konkrétně je použita šifra AES-128 v~operačním módu CBC s~výplní PKCS\#7 a~HMAC s~hašovací funkcí SHA-256.)

Z~hlediska implementace jednoduchého šifrování souborů pomocí hesla je použití knihovny cryptography velmi přímočaré. Výsledný kód provádějící samotné kryptografické operace sestává z~pouhých 5~příkazů s~použitím modulu Fernet a~6~příkazů za použití hazmat modulu. V~prvním případě musí uživatel knihovny identifikovat nutnost použití funkci pro odvození klíče (která se nachází v~nízkoúrovňovém ``hazardním'' modulu), určit počet iterací a~správně převést klíč do kódování base64. V~druhém případě musí navíc vybrat vhodnou šifru a~operační mód, resp.\ identifikovat použití autentizované šifry namísto klasické symetrické šifry, které dokumentace knihovny odděluje. (V~našem kódu jsme zvolili AES-256 v~módu GCM.) Autentizační tag knihovna automaticky připojí za šifrový text a~při dešifrování očekává jeho přítomnost, jak je popsáno v~dokumentaci.

Knihovna nabízí podpůrné funkce například pro generaci klíčů, na druhou stranu nezahrnuje API pro generování náhodných čísel, resp.\ jednorázových hodnot (nonce). V~dokumentaci je popsáno, jak by měly být nonce generovány pomocí standardní knihovny, ale pravděpodobně není dostatečně zdůrazněn význam správné volby náhodného generátoru, čemuž nasvědčují chybná použití, která jsme dohledali~\cite{pyca-misuse-random}. Dalším omezením vysokoúrovňového API je skutečnost, že lze pomocí něj klíče pouze generovat, ale ne třeba odvodit z~hesla nebo je ustanovit pomocí asymetrického schématu. Pro ošetřování chyb knihovna používá výjimky, jak je typické pro jazyk Python.

Dokumentace je úplná, srozumitelně popisuje účel knihovny, její funkce, a~navíc poskytuje odkazy na zdroje vysvětlující základní koncepty kryptografie. Dále dokumentace dává důraz na význam jednotlivých elementů kryptografie, např.\ tajnost klíčů, a~obsahuje ukázky kódu (resp.\ tutoriály) pro běžná použití jak na vysoké úrovni (ověření X.509 certifikátu, vygenerování \textit{Certificate Signing Request} (CSR), autentizované symetrické šifrování), tak na nízké úrovni (použití symetrických šifer, hašovacích funkcí, atd.). Ukázky kódu používají bezpečné algoritmy a~realistické scénáře použití (např.\ správně generované klíče). U~nebezpečných algoritmů a~stejně tak globálně v~celém nízkoúrovňovém modulu je zobrazeno varování, že je jejich použití potenciálně nebezpečné; stejně tak i~v~``nebezpečné'' nízkoúrovňové sekci jsou důsledně rozlišovány bezpečné algoritmy a~módy od těch zranitelných. Dokumentace knihovny je přehledná a~snadno prohledávatelná a~u~každého algoritmu je detailně popsáno jeho zamýšlené použití, například u~operačního módu XTS je zdůrazněno, že je určen pouze pro šifrování disků.

\subsubsection*{PyCryptodome}

Knihovna PyCryptodome je svým rozhraním srovnatelná s~hazardním modulem knihovny cryptography. Z~hlediska členění nerozlišuje autentizované a~neautentizované symetrické šifry (autentizace šifrovaných dat je provedena voláním zvláštní metody) a~například funkce pro odvození klíče z~hesla jsou poněkud nečekaně umístěny do modulu \texttt{Crypto.Protocol}. Na rozdíl od cryptography tato knihovna zpřístupňuje explicitní API pro generování kryptograficky bezpečných náhodných dat.

Použití knihovny k~autentizovanému zašifrování souboru heslem bylo podobně jako u~cryptography poměrně přímočaré. Na rozdíl od cryptography odlišuje explicitně PyCryptodome šifrový text od autentizačního tagu. Dalším rozdílem je, že PyCryptodome podporuje implicitní bezpečné vygenerování nonce pro šifrování --- uživatel jej nemusí sám obstarávat, pouze si jej od knihovny vyžádá, aby ho mohl serializovat. Výsledný kód, který používá rozhraní knihovny, má opět pouhých 5~příkazů (řádků).

V~tomto případě se nicméně ukazuje, že je knihovna do určité míry nekonzistentní v~jednoduchosti použití jednotlivých algoritmů. Zatímco v~případě autentizovaného šifrování v~módu GCM nebo EAX lze otevřený text jednoduše předat metodě \texttt{Cipher.encrypt\_and\_digest}, například při použití operačního módu CBC musí uživatel sám otevřený text zarovnat na násobek délky bloku. (Stejná je situace i~v~nízkoúrovňovém modulu knihovny cryptography, jehož použití koneckonců podobně jako PyCryptodome od uživatele očekává hlubší znalost kryptografických konceptů.)

Nízkoúrovňové API knihovny je celkově flexibilní a~ve většině případů dovoluje zvolit algoritmus a~použít libovolné (i~nebezpečné) parametry. Z~nějakého důvodu ale pouze v~některých situacích na slabé parametry upozorňuje a~chybu nelze obejít~\cite{pcd-issue-720}. Knihovna nemá vy\-so\-ko\-ú\-rov\-ňo\-vé API, přestože existují roky staré GitHub issues, které ho navrhují~\cite{pcd-issue-57}. Výchozí hodnoty nespecifikovaných parametrů (např.\ IV u~symetrické šifry) jsou bezpečné, pořád ale platí, že nepovinné parametry jsou v~knihovně spíš výjimkou a~většinu konfigurace musí provést uživatel. Chyby jsou ošetřovány pomocí výjimek, ale někdy nevhodným způsobem~\cite{pcd-issue-320}.

Dokumentace je logicky členěná a~obsahuje úvod s~rozcestníkem a~popisem knihovny, navigace i~vyhledávání v~ní je snadné. V~jednotlivých sekcích dokumentace jsou stručně vysvětleny příslušné kryptografické koncepty (např.\ rozdíl mezi symetrickým a~asymetrickým šifrováním) a~velmi stručně popsán význam parametrů. Přesto jsou dohledatelné případy, kdy uživatel parametry zvolí špatně~\cite{pythonspider-issue}.

Zvláštní kapitola dokumentace obsahuje několik stručných a~bezpečných ukázek kódu pro symetrické (AES s~HMAC, AES-OCB) a~asymetrické (RSA) šifrování a~generování RSA klíčů. U~jednotlivých algoritmů jsou taktéž stručné ukázky použití. Dokumentace vizuálně odděluje doporučené (bezpečné) algoritmy od zastaralých a~prolomených; u~nebezpečných algoritmů je zobrazeno varování a~odkaz na bezpečnou alternativu.

Některé části dokumentace jsou neaktuální. Např.\ záložka ``Future plans'' obsahuje v~seznamu budoucích plánů již implementované algoritmy (např.\ bcrypt).

\section{Hledání chyb v použití}
\label{analyza-hledani}

Jedním z~hlavních cílů této práce je prozkoumat způsoby, kterými lze identifikovat časté chyby, kterých se uživatelé dané knihovny dopouští. V~následujících odstavcích představíme několik způsobů, které se zdály být přípustné, jejich přednosti a~slabiny, a~dále vybrané způsoby aplikujeme na zkoumané knihovny.

\subsection{Postup}

\subsubsection*{CVE záznamy závislých aplikací}

První nápad spočíval v~identifikaci a~výběru aplikací, které danou knihovnu používají, a~analýze CVE záznamů těchto aplikací s~cílem zjistit, jestli tyto zranitelnosti nějak souvisí s~chybným použitím knihovny. Předností takového přístupu je skutečnost, že zachytí skutečně závažné chyby, kterých se vývojáři při použití knihovny dopustili a~které byly během testování přehlédnuty.

Bohužel se v~průběhu zkoumání ukázalo, že tento postup vyžaduje poměrně hodně námahy a~přesto neposkytuje velmi dobré výsledky. Jedním důvodem je samotná identifikace závislých aplikací --- zatímco některé jazyky, resp.\ ekosystémy (jako třeba \textit{Python Package Index} (PyPI) pro jazyk Python nebo databáze balíčků \textit{crates.io} jazyka Rust) poskytují nástroje pro vyhledání ``reverzních závislostí'' (\textit{reverse dependencies}) pro danou knihovnu, u~knihoven pro jazyk C takové nástroje neexistují. V~těchto případech jsme byli schopni aplikace dohledat jedním ze dvou způsobů.

Prvním způsobem je vyhledávání ve správcích balíčků, jako je \textit{Advanced Package Tool} (apt) používaný linuxovou distribucí Debian. Například v~apt je možné vyhledat reverzní závislosti pro daný balíček příkazem \texttt{apt-cache rdepends <název balíčku>}. Druhou přípustnou strategií je prohledávání veřejných repositářů s~kódem, například prostřednictvím platformy GitHub. Vyhledávat lze například názvy funkcí, importovaných modulů nebo konstant specifických pro hledanou knihovnu (např.\ \texttt{EVP\_CIPHER\_CTX} v~případě OpenSSL nebo \texttt{\#include~<gcrypt.h>} pro knihovnu libgcrypt). Takto lze zároveň vyhledávat konkrétní případy použití, například vyhledat pouze kód používající funkce pro šifrování nebo pouze kód validující X.509 certifikáty.

Nalezení vhodných aplikací bohužel stále nestačilo k~úspěšnému aplikování zamýšleného postupu. Největším problémem se ukázalo být to, že vůči velkému počtu CVE aplikací byla CVE související se špatným použitím kryptografických knihoven velmi vzácná a~od analytika tak tento přístup vyžadoval projít desítky aplikací --- a~ani tehdy nebylo možné výsledky dobře zobecnit\footnote{Aplikování tohoto postupu na vybrané kryptografické knihovny (včetně OpenSSL) demonstrují ve svých bakalářských pracích Matěj Douša~\cite{matej} a~Kirill Leonov~\cite{kirill}.}.

Vzhledem k~tomu, že výsledná metoda má být aplikovatelná v~rozumném čase na větší počet kryptografických knihoven, jsme proto tento přístup opustili.

\subsubsection*{On-line diskusní fóra}

Postup, který je poměrně dobře zobecnitelný na obecnou (potenciálně jinou než kryptografickou) knihov\-nu, vychází z~dostupných informací obsažených ve veřejných komunikačních kanálech, které vývojáři typicky používají pro získávání informací o~použití knihoven, příp.\ pro komunikaci se správci knihovny ohledně jejích nedostatků. Mezi takové zdroje patří především \textit{issues} u~knihoven vy\-ví\-je\-ných na centralizované platformě (GitHub, GitLab, \dots), on-line diskuzní fóra jako například Stack Overflow, případně dedikované kanály pro komunikaci se správci knihovny (mailing listy, Discord servery, apod.).

Relevanci diskuzních fór jako Stack Overflow jsme již nastínili v~kapitole~\ref{pouziti}. Klíčové z~hlediska hledání častých chyb je pozorování ohledně toho, kdo se diskuzí na těchto fórech účastní. Diskuze na fóru Stack Overflow probíhá formou otázek a~odpovědí, lze proto usuzovat, že v~ní budou figurovat jak noví uživatelé, jejichž otázky budou moct sloužit jako indikátory srozumitelnosti knihovny, tak i~zkušenější vývojáři, jejichž odpovědi mohou potenciálně odhalit zažité špatné praktiky.

V~neposlední řadě se dá předpokládat, že knihovna, která svým rozhraním a~dokumentací bude uživatele navádět ke správnému použití (např.\ bezpečnými ukázkami kódu), bude v~takových fórech reprezentována jen malým počtem specifických otázek s~bezpečnými odpověďmi, oproti tomu nesrozumitelné knihovny budou diskutovány horlivěji a~špatně dokumentované knihovny budou náchylnější k~nebezpečným praktikám v~odpovědích.

Nevýhodou tohoto postupu je omezená validita výsledků --- analýza příspěvků nám dá dobrou představu, které aspekty použití knihoven jsou pro uživatele problematické a~jak kvalitní jsou doporučení, která si navzájem uživatelé těchto fór dávají, nemáme ale jistotu, že jsou tytéž chyby reflektovány v~testovaném produkčním kódu.

\subsubsection*{Velké jazykové modely}

Posledním --- a~do jisté míry experimentálním --- postupem, kterým lze potenciálně odhadnout pravděpodobnost, že bude knihovna svými uživateli použita bezpečně, je analýza výstupů velkých jazykových modelů, jako jsou např.\ ChatGPT nebo GitHub Copilot. Tato domněnka vychází ze dvou pozorování. Zaprvé jsou tyto nástroje dnes vývojáři široce používány~\cite{ai-hallucinate, github-copilot}, zadruhé jde o~jazykové modely, které jsou trénovány na existujícím veřejně dostupném kódu~\cite{github-copilot} a~můžeme proto předpokládat, že časté chyby (ale i~celkový přístup k~použití knihovny) skutečných vývojářů se do odpovědí těchto modelů nějakým způsobem promítnou.

Takový přístup s~sebou nese samozřejmě i~některé nedostatky, které brání jeho zobecnitelnosti. Zaprvé jsou zmíněné jazykové modely trénované pouze na datech z~určitého časového rozmezí a~nemusí proto mít přístup k~aktuálním informacím --- mohou tak vycházet z~informací o~starších verzích knihoven nebo data o~dané knihovně vůbec nemít. Dalším omezením je skutečnost, že jsou tyto modely closed-source a~nemáme tudíž dobrou představu o~jejich implementaci a~datech, na kterých se modely učily. Proto tento přístup uvádíme spíš jako doplnění k~již zmíněným přístupům, případně jako návrh k~dalšímu výzkumu.

Výše popsaný postup v~této práci demonstrujeme na jednotlivých knihovnách podobným způsobem, kterým jsme hodnotili návrh rozhraní. Konkrétně skrze webovou aplikaci ChatGPT\footnote{\url{https://chat.openai.com}} požádáme model GPT~3.5, aby implementoval zašifrování souboru pomocí hesla, s~výjimkou knihovny rustls, u~které budeme požadovat navázání bezpečného TLS spojení se serverem na doméně \textit{fit.cvut.cz}. Při použití tohoto postupu je třeba mít na paměti, že ChatGPT nemá paměť --- na dotazy v~novém vláknu odpoví nezávisle na předchozích konverzacích potenciálně jiným způsobem. Z~tohoto důvodu je vhodné tentýž dotaz položit v~různých vláknech opakovaně a~závěry vyvozovat až z~trendů napříč odpověďmi. Vzhledem k~tomu, že tento experiment není hlavním účelem této práce, zopakujeme každý dotaz 5krát a~výstupy zanalyzujeme ručně. V~úvahu přichází použití webového API ChatGPT a~automatická analýza výstupů pomocí statických analyzátorů nebo přímo nástrojů pro detekování kryptografických chyb\footnote{Například nástroj CRYScanner~\cite{cryscanner}.}, to však spadá mimo rozsah této práce. Všechny odpovědi LLM, ze kterých v~této práci vycházíme, jsou opět k~dispozici na přiloženém médiu, a~sice v~adresáři \texttt{appendices/llm-outputs}.

\subsection{Výsledky}

\subsubsection*{OpenSSL}

U~knihovny OpenSSL přichází v~úvahu vyjít z~\textit{GitHub issues}, resp.\ \textit{GitHub discussions}, mailing listu \textit{openssl-users} nebo z~výsledků vyhledávání na Googlu a~na Stack Overflow.

Otázky položené v~GitHub diskuzích odpovídají předchozím zjištěním: Kód používající Open\-SSL je komplikovaný a~náchylný na chyby~\cite{openssl-disc-22838}, některé funkce nejsou dostatečně dobře zdokumentované~\cite{openssl-disc-23026} a~API knihovny je pro uživatele matoucí a~nijak nevaliduje argumenty, což může vést k~závažným chybám~\cite{openssl-disc-21610}. Kromě toho se v~diskuzích projevují i~zásadní nepochopení kryptografických konceptů (např.\ dešifrování dat zašifrovaných neautentizovanou šifrou~\cite{openssl-disc-23198}) a~programování v~nízkoúrovňových jazycích~\cite{openssl-disc-22170}.

Pro zhodnocení výstupu LLM byl zvolen následující \textit{prompt}:

\begin{displayquote}
\textit{Can you show me an example of encrypting a~file with a~password in C or C++ using the openssl crypto library?}
\end{displayquote}

V~3 z~5~případů byl kód v~odpovědi katastrofální: Heslo bylo v~textové podobě a~bez jakékoli kontroly jeho délky přímo předáno funkci \texttt{EVP\_EncryptInit\_ex} jakožto klíč a~pro inicializační vektor byla zvolena výchozí hodnota NULL (tedy nulový IV). Bohužel šel kód navzdory takto závažným chybám bez varování zkompilovat a~pakliže uživatel při testování zadal dostatečně dlouhé heslo, kód mohl dokonce působit dojmem, že funguje, což je z~jistého pohledu ještě horší. Z~ostatních dvou výstupů jeden vůbec heslo nepoužil a~vygeneroval náhodný klíč, pouze v~jednom případě se tedy LLM podařilo vygenerovat kód, který odvodil klíč a~IV z~hesla a~náhodně vygenerované soli a~do souboru kromě ŠT serializoval i~tuto sůl. Bohužel k~odvození klíče ale použil zastaralou\footnote{V~dokumentaci sice jako zastaralá označená není, ale jeden ze správců projektu v~diskuzi~\cite{openssl-disc-23198} píše: ``\textit{Firstly: don't use EVP\_BytesToKey()\dots we should deprecate it (actually I~thought it already was deprecated and was surprised to learn that it isn't).}''} funkci \texttt{EVP\_BytesToKey} s~velmi slabými parametry (pouze jednou iterací SHA-256). Ve všech případech používal kód šifru AES-256 v~operačním módu CBC a~šifrový text tedy nebyl autentizován.

\subsubsection*{libgcrypt}

Na rozdíl od OpenSSL nepoužívá libgcrypt k~vývoji platformu GitHub, vyjdeme proto z~pří\-spěv\-ků na Stack Overflow vyhledáním klíčových slov ``libgcrypt how to'' (53 vláken\footnote{Viděno 2024-04-23.}) a~``libgcrypt encrypt'' (63 vláken).

Přestože knihovna od uživatelů očekává základní znalosti aplikované kryptografie, nalezená vlákna nenasvědčují tomu, že by takový předpoklad byl vždy splněn: Jednomu tazateli nebylo jasné, jak zkontrolovat správnost hesla při dešifrování~\cite{so-14548748}, dalšímu dělaly problém rozdílné délky klíčů~\cite{so-17711691}, dalšími problémy bylo zarovnání dat~\cite{so-56266972, so-35835927}, fungování specifických operačních módů~\cite{so-21882115} nebo výběr vhodných hodnot pro parametry KDF~\cite{so-14583733}. Jeden tazatel hledal v~knihovně jednoduché API na asymetrické šifrování a~dešifrování souborů, pro jehož použití by nepotřeboval detailní kryptografické znalosti~\cite{so-4124182}.

Některé příspěvky můžeme připisovat nedostatečně obsáhlé dokumentaci, která komplikovala použití specifických algoritmů~\cite{so-71102901, so-56509552}, nebo nedostatečnému důrazu na odlišení nebezpečných konfigurací~\cite{so-53749797}.

Posledním kritickým problémem, se kterými se mnoho tazatelů potkalo, bylo nepochopení základních principů kódování dat, tj.\ například použití C funkce \texttt{strlen} pro zjištění délky šifrového textu (sic)~\cite{so-65209512}, použití C++ řetězců (\texttt{std::string})~\cite{so-26189967}, apod.~\cite{so-14174486, so-5852437, so-14196986}.

Z~hlediska výstupu jazykového modelu ChatGPT si libgcrypt vedla srovnatelně špatně jako OpenSSL. Použitý dotaz byl analogický:

\begin{displayquote}
\textit{Can you show me an example of encrypting a~file with a~password in C or C++ using the libgcrypt library?}
\end{displayquote}

Ani jedno z~5~opakování nevyprodukovalo bezpečný kód. První výstup jako jediný odvodil klíč pomocí KDF, bohužel ale použil konstantní sůl a~z~hesla kromě klíče odvozoval i~IV, který by byl v~důsledku také konstantní a~tím porušil IND-CPA šifrování. Kromě toho kód nebyl funkční --- kvůli chybějícím deklaracím nešel ani zkompilovat. Další 4~vygenerované příklady byly z~hlediska kompilace validní, ale použily heslo přímo jako klíč bez jakéhokoli odvození a~bez jakékoli kontroly délky. Přestože rozhraní knihovny libgcrypt přijímá jako parametr délku klíče, LLM neměl problém za tento parametr dosadit délku klíče, která by byla správná, a~nikoli délku skutečně předaného pole. Pakliže z~výstupů LLM můžeme odhadovat způsob, kterým vývojáři knihovnu používají, podporuje toto zjištění argument pro silné typování parametrů. Mezi další problémy, které kód vykazoval, patří chybějící serializace potřebných údajů do výstupního souboru nebo použití konstantního IV (v~kódu jednoho z~výstupů bylo dokonce jako IV použito samotné heslo).

\subsubsection*{rustls}

Vývoj knihovny probíhá na GitHubu, issues se však z~drtivé většiny netýkají používání knihovny. Při hodnocení jsme proto vyšli z~265~příspěvků na Stack Overflow\footnote{Viděno 2024-04-25.} získaných dotazem ``rustls''.

Rovněž u~knihovny rustls byly výsledky konzistentní s~tím, co jsme popsali v~předchozích kapitolách --- díky vysokoúrovňovému API s~bezpečnými výchozími hodnotami nevykazovaly příspěvky známky nebezpečného používání. Z~16~příspěvků, které se skutečně týkaly použití knihovny, se 4 zabývaly tím, jak použít méně bezpečné funkce knihovny (např.\ přidat certifikáty podepsané samy sebou)\footnote{Příspěvky s~ID 72846337, 74521227, 60751795 a~70331834.}; další 3 řešily použití nepodporovaných šifrovacích systémů (\textit{cipher suites})\footnote{Příspěvky 41846521, 61169422 a~8411718.}. Mezi další témata patřilo  kódování dat (1~příspěvek), mechanismy jazyka Rust (2~příspěvky), otázka k~funkci, kterou rustls vůbec nepodporuje (1~příspěvek) nebo použití v~kombinaci s~jinou knihovnou/protokolem (2~příspěvky).

Použití umělé inteligence vedlo v~případě knihovny rustls k~poměrně zajímavým výsledkům. Přestože byl všechen vygenerovaný kód sémanticky správný a~bezpečný, ani v~jednom případě nebyl skutečně zkompilovatelný --- používal totiž názvy struktur a~funkcí, které byly v~novějších verzích přejmenované (přestože byl kód kompilován oproti verzi knihovny, kterou doporučil LLM). Dotaz položený jazykovému modelu byl následující.

\begin{displayquote}
\textit{Can you show me code to establish a~secure connection to the server ``fit.cvut.cz'' using the rustls library?}
\end{displayquote}

\subsubsection*{ring}

U~knihovny ring lze opět vyjít z~GitHub issues a~fóra Stack Overflow. Vzhledem ke konzervativnímu rozhraní knihovny nehrozí, že by uživatelé volili zranitelné algoritmy nebo parametry. Jediné issue\footnote{Viděno 2024-04-23.}, které se týkalo nejasností ohledně použití knihovny, naráželo na tentýž problém s~vlastností \texttt{NonceSequence}, který jsme již popsali v~sekci~\ref{analyza-dok-a-navrh}~\cite{ring-issue}.

Hledání relevantních příspěvků na Stack Overflow bylo poněkud ztíženo velmi generickým názvem knihovny --- ``ring'' může v~kontextu kryptografie označovat mimo jiné tzv.~klíčenky (\textit{key ring}), algebraické okruhy, apod. Rozumné výsledky poskytuje alespoň dotaz ``[rust] ring''.

Z~příspěvků na Stack Overflow nevyplynulo, že by uživatelé knihovny ring měli zásadní potíže s~jejím použitím. Jeden příspěvek se týkal čistě technických aspektů jazyka Rust~\cite{so-66193072}, další tazatel nepochopil správně funkci nonce při dešifrování~\cite{so-77593524} --- jeho kód tak byl nefunkční, ale nikoli nebezpečný. Zbytek relevantních příspěvků narážel na kódování dat (URL, hexadecimální, formát DER, atd.)~\cite{so-66492119, so-52888842, so-72872350, so-70478735}.

V~použití knihovny ring dosahuje ChatGPT podobných výsledků jako u~knihovny rustls --- přestože byl všechen vygenerovaný kód v~principu bezpečný, opět ani v~jednom případě nešel zkompilovat a~v~3 z~5 případů se navíc vůbec nepokoušel použít heslo (místo toho vygeneroval nový náhodný klíč). Kód z~posledního výstupu navíc nejprve redundantně vygeneruje náhodný klíč a~hned poté z~hesla odvodí druhý klíč, který vzápětí použije k~šifrování. Zajímavým pozorováním je, že kdyby byl kód ``syntakticky'' správně\footnote{Slovo ``syntakticky'' zde používáme v~neformálním smyslu. Formálně byl kód syntakticky správný (tj.\ řídil se gramatikou jazyka Rust), nedodržoval však rozhraní knihovny --- nebyl \emph{sémanticky} správný.}, jako jediný napříč všemi zkoumanými knihovnami by používal autentizovanou šifru (AES-256-GCM) --- to je přirozeným důsledkem toho, že knihovna neautentizované šifry vůbec nenabízí.

\subsubsection*{cryptography.io}

Stack Overflow čítá 242 dotazů se štítkem označujícím tuto knihovnu, \textit{python-cryptography}. Výrazným způsobem jsou v~nich zastoupena zejména témata interoperability s~dalšími knihovnami nebo programovacími jazyky, serializace a~deserializace asymetrických klíčů (formáty DER a~PEM, ASN.1, apod.) a~nepochopení konceptů kódování dat (např.\ rozdíl mezi UTF-8 řetězcem a~polem bajtů). Mnoho otázek zároveň reflektuje kryptografickou neznalost tazatelů --- jeden dotaz~\cite{so-66856419} zaměňuje heslo a~klíč, jiný~\cite{so-76154142} míří na zvolení vlastního klíče pro šifru Fernet --- jeho autor si nakonec s~pomocí ChatGPT odpovídá sám, bohužel velmi zavádějícím způsobem. Další tazatel vyhledával pomoc s~``šifrováním pomocí MD5''~\cite{so-55096978} a~hned několik dotazů bylo zapříčiněno nepochopením podstaty IV u~blokových šifer~\cite{so-71430014, so-52693398, so-57544299}. Přestože zvolená konfigurace algoritmů, operačních módů, atd., byla často bezpečná, tazatelé chybovali na konceptuální úrovni --- častým jevem bylo šifrování uživatelských hesel dočasným klíčem místo hašování, resp.\ použití KDF~\cite{so-77542044, so-62333295, so-63995169}.

Kód v~odpovědích modelu ChatGPT osciloval mezi použitím vysokoúrovňové šifry Fernet a~nízkoúrovňového modulu. V~jednom případě si model ``vymyslel'' vlastní funkci pro odvození klíče Fernet z~hesla, tato funkce ale nedávala žádný smysl. V~ostatních 4~případech byl kód funkční a~bezpečný, zadání ovšem splňovaly pouze 2~výstupy, které přímo používaly šifru AES (konkrétně neautentizovanou AES-256-CFB) --- model totiž nedokázal správně použít autentizovanou šifru Fernet s~heslem; místo toho generoval náhodný klíč.

\subsubsection*{PyCryptodome}

Analýza otevřených issues\footnote{Viděno 2024-04-25.} v~GitHub repositáři PyCryptodome ukazuje na dva nedostatky: Některá API jsou matoucí, vývojářům dělá problém šifrování velkých souborů po částech~\cite{pcd-issue-482, pcd-issue-646} a~mechanismus pro ošetřování chyb není dostatečně granulární~\cite{pcd-issue-320}.

Problémy, které odhalil průzkum fóra Stack Overflow, byly do jisté míry srovnatelné s~knihovnou cryptography. Uživatelé se opět potýkali s~kódováním dat --- jeden tazatel~\cite{so-54752085} například ŠT rozděloval po znacích \textit{end of line} ---, (de)serializací asymetrických klíčů, interoperabilitou s~dalšími knihovnami a~pochopením základních kryptografických konceptů --- opět například zaměňovali heslo se symetrickým klíčem~\cite{so-61645823} nebo odvozovali klíč z~veřejných informací~\cite{so-60476856}.

Oproti konkurenční knihovně jazyka Python novou kategorií dotazů byly nejasnosti ohledně API knihovny způsobené zažitými návyky z~knihovny PyCrypto~\cite{so-54964354} nebo používáním ná\-vra\-to\-vých hodnot místo výjimek~\cite{so-63655263}. V~některých případech zase nebyla uživatelům jasná dokumentace\footnote{Například v~příspěvcích s~ID 46132222, 65958021, 56725545, 43462061 nebo 73024503.}.

Překvapivým zjištěním byla jistá dvojsečnost implicitních náhodných IV, které knihovna generuje při inicializaci šifry. Tazatel se v~příspěvku~\cite{so-47990482} diví, že šifrování pomocí AES-256 s~neměnným klíčem a~daty produkuje pokaždé jiný ŠT. Jako řešení autor navzdory správným doporučením ostatních účastníků diskuze neoznačil přečtení a~uložení IV, které za něj bezpečným způsobem zvolila knihovna, ale zvolení statického IV s~textovou hodnotou \texttt{0123456789abcdef}\footnote{Jak řekl Douglas Adams: ``\textit{A~common mistake that people make when trying to design something completely foolproof is to underestimate the ingenuity of complete fools.}''}. Ze samotného vlákna sice neusoudíme, jakou strategii tazatel nakonec použil ve svém programu, můžeme ale předpokládat, že další uživatelé, kteří budou mít podobný problém a~příspěvek navštíví, se s~nenulovou pravděpodobností budou řídit řešením, které autor označil jako správné.

Umělá inteligence si (podobně jako u~předchozí knihovny) vedla při použití PyCryptodome z~bez\-peč\-nost\-ní\-ho hlediska dobře, z~hlediska funkčního už tolik ne. Jedna verze kódu místo modulu \texttt{Crypto.Hash} pro inicializaci funkce PBKDF2 použila standardní knihovnu \texttt{hashlib}, která má odlišné rozhraní, než se kterým PyCryptodome počítá. Ve zbylých případech byl kód funkční v~tom smyslu, že proběhl bez vyvolání výjimky, používal ale šifru AES v~režimu CBC, přičemž poslední blok OT zarovnal na 16 bajtů mezerami (namísto standardní výplně PKCS\#7), což mělo za následek nejednoznačnost délky OT --- případné mezery, resp.\ bajty s~hodnotou \texttt{0x20}, na konci šifrovaných dat, mohly tak být při dešifrování odstraněny.
